for(var in seq) {
  //do_something
}
///
while(cond) {
  //do_something
}
///
if(cond) {
  //do_something
}
else {
  //do_something
}
///
function_name <- function(var) {
  //do_something
  return(var)
}
///
CHIFFRE : 0|..|9
LETTRE : a|..|z|A|..|Z
NUM : CHIFFRE [ CHIFFRE ]
ID : [ . | epsilon ] [LETTRE [ LETTRE | CHIFFRE | . | _ ]]
AFFECTATION : ID AFFOP EXPR
EXPR : TERM [ARTHOP TERM]
TERM : ID | NUM | ( EXPR )
SI : if ( CONDS ) { INST } [ else { INST } | epsilon ]
BOUCLE : BOUCLE_FOR | BOUCLE_WHILE
BOUCLE_WHILE : while ( COND ) { INST }
BOUCLE_FOR : for ( SEG ) { INST }
CONDS : [!]COND [ || COND | && COND]
COND1 : [!]COND2
COND2 : VAR RELOP VAR
PRINT : print ( VAR )
INPUT : ID <- readline(prompt"//msg")
RELOP : == | != | < | <= | > | >=
AFFOP : <- | <<- | = | -> | ->>
ARTHOP : + | - | * | /
FUNCTION : ID AFFOP function (VAR) { INSTS return(VAR)}
VAL : LOGICAL | NUMERIC | INTEGER | COMPLEX | CHARACTER | RAW | VECTOR | LIST | MATRICE | ARRAY
///
TOKENS :
IF_TOKEN , ELSE_TOKEN , REPEAT_TOKEN , WHILE_TOKEN , FUNCTION_TOKEN , FOR_TOKEN , IN_TOKEN , NEXT_TOKEN , BREAK_TOKEN , TRUE_TOKEN , FALSE_TOKEN , NULL_TOKEN , Inf_TOKEN , NaN_TOKEN ,
NA_INTEGER_TOKEN , NA_REAL_TOKEN , NA_COMPLEX_TOKEN , NA_CHARACTER_TOKEN , PLUS_TOKEN , MOINS_TOKEN , MULT_TOKEN , DIV_TOKEN , EXPONENT_TOKEN , MODULUS_TOKEN , INT_DIV_TOKEN ,
INF_TOKEN , SUP_TOKEN , INFEG_TOKEN , SUPEG_TOKEN , EQUAL_TOKEN , NOT_EQUAL_TOKEN , LOGICAL_NOT_TOKEN , LOGICAL_AND_TOKEN , LOGICAL_OR_TOKEN , LEFT_ASGN_TOKEN , RIGHT_ASGN_TOKEN .
